//关联关系对象
//一个对象可以与其他对象相联系。 就像数据库中的主外键关系一样，数据表A的某一个字段是数据表B的外键，只有表B中存在的数据才可插入进表A中的字段。

var __Request = require("./../bmob-cloud-common").Request;
var assert = require("assert");

module.exports = (function () {
    var model = {};

    /**
     添加关联关系
     为了更新 Pointer 的Key类型，Bmob提供特殊的操作来原子化地添加和删除一个指针，我们可以像这样添加一行记录时并添加一个指针：

     function onRequest(request, response, modules) {

     var rel = modules.oRelation;
     rel.add({
     "table":"GameScore",
     "data":{"game":{"__type":"Pointer","className":"Game","objectId":"ekZq111a"}}
     },function(err,data){
     //回调函数
     });
     }
     为了更新 Relation 的Key类型，Bmob提供特殊的操作来原子化地添加和删除一个或多个关系，我们可以像这样添加一行记录时并添加多个关系:

     rel.add({
     "table":"GameScore",
     "data":{"gamerel":{"__op":"AddRelation","objects":[{"__type":"Pointer","className":"Game","objectId":"ekZq111a"},{"__type":"Pointer","className":"Game","objectId":"80SLHHHj"}]}}
     },function(err,data){
     //回调函数
     });
     */
    model.add = function (request, callback) {
        __Request("classes", request.table, request.objectId, request.objectId == null ? 'POST' : 'PUT', request.data, callback);
    }

    /**
     修改关联对象
     为了更新 Pointer 的Key类型，Bmob提供特殊的操作来原子化地添加和删除一个指针，我们可以像这样添加一个指针:

     rel.update({
     "table":"GameScore",
     "objectId":"8106dc7c9e",
     "data":{"game":{"__type":"Pointer","className":"Game","objectId":"80SLHHHj"}}
     },function(err,data){
     //回调函数
     });
     为了更新 Relation 的Key类型，Bmob提供特殊的操作来原子化地添加和删除一个或多个关系，我们可以像这样添加多个关系:

     rel.update({
     "table":"GameScore",
     "objectId":"8106dc7c9e",
     "data":{"gamerel":{"__op":"AddRelation","objects":[{"__type":"Pointer","className":"Game","objectId":"ekZq111a"}]}}
     },function(err,data){
     //回调函数
     });
     */
    model.update = function (request, callback) {
        __Request("classes", request.table, request.objectId, 'PUT', request.data, callback);
    }

    /**
     查询关联对象
     有几种方式来对关系 Relation 或 指针 Pointer 类型数据进行查询, 如果您将要获取对象中有个Key类型是关系 Relation 或 指针 Pointer，这都说明你要获取的对象是匹配到另一个特殊（关联或指向）的对象的, 您可以用一个 where 参数查询, 自己使用 __type 构造一个 Pointer, 就像你构造其他数据类型一样。举例说, 如果每一条评论(Comment对象)有一个Key叫post，类型是Pointer，并且指向了一个具体的帖子(Post对象，用objectId表示一个帖子)，那么您可以使用下面的请求获取一个帖子的所有评论:

     rel.query({
     "table":"Comment",
     "where":{"post":{"__type":"Pointer","className":"Post","objectId":"l4fQ999O"}},
     },function(err,data){
     //回调函数
     });
     如果您想要获取对象, 这些对象的一个字段指向的对象是符合另一个查询的, 您可以使用 $inQuery 操作符，注意默认的 limit 是 100 而且最大的 limit 是 1000，这个限制同样适用于内部的查询, 所以对于较大的数据集您可能需要细心地构建查询来获得期望的行为。举例说, 假设您有一个 帖子(Post)类和一个评论(Comment)类, 每个评论(Comment)都有一个指向它的帖子(Post)的关系Key名为post，并且类型为Pointer, 您可以找到所有有图片的帖子(Post)的评论(Comment):

     rel.query({
     "table":"Comment",
     "where":{"post":{"$inQuery":{"where":{"image":{"$exists":true}},"className":"Post"}}},
     },function(err,data){
     //回调函数
     });
     同理，使用下面的请求，您可以找到所有没有图片的帖子(Post)的评论(Comment):

     rel.query({
     "table":"Comment",
     "where":{"post":{"$notInQuery":{"where":{"image":{"$exists":true}},"className":"Post"}}},
     },function(err,data){
     //回调函数
     });
     如果您想获取的对象，是其父对象的关系 Relation 类型的Key的所有成员的话, 您可以使用 $relatedTo 操作符, 假设您有一个帖子(Post)类和一个系统默认的用户(_User)类, 而每一个帖子(Post)都可以被不同的用户(_User)所喜欢。 如果帖子(Post)类下面有一个Key名为likes，且是 Relation 类型, 存储了喜欢这个帖子(Post)的用户(_User)。那么您可以找到喜欢过同一个指定的帖子(Post)的所有用户：

     rel.query({
     "table":"Comment",
     "where":{"$relatedTo":{"object":{"__type":"Pointer","className":"Post","objectId":"l4fQ999O"},"key":"likes"}},
     },function(err,data){
     //回调函数
     });
     还可以使用组合查询，比如下面这样，判断用户是否喜欢(likes)过这个帖子：

     rel.query({
     "table":"Comment",
     "where":{"likes":{"$inQuery":{"where":{"objectId":"l3xRGGGa"},"className":"_User"}}, "objectId":"l4fQ999O"},
     "limit":10,
     "count":true
     },function(err,data){
     //回调函数
     });
     返回结果集如下：

     {
     count: 1
     results: [ ]
     }
     你可以做如下判断，如果count=1，表明用户喜欢的这个帖子objectId存在，即用户喜欢过这个帖子；若count=0, 表明用户没有喜欢过这个帖子。

     在某些情况之下，您可能需要在一个查询之中返回关联对象的多种类型，您可以通过传入字段名称到include参数中，多个字段名称用,间隔， 比如，我们想获得最近的10篇评论，而您想同时得到它们相关的post： include的Key必须是Pointer类型

     rel.query({
     "table":"Comment",
     "order":"-createdAt",
     "limit":10,
     "include":"post"
     },function(err,data){
     //回调函数
     });
     不是作为一个 Pointer 类型表示，post字段现在已经被展开为一个完整的帖子(Post)对象， __type 被设置为 Object 而 className 同样也被提供了。 举例说， 一个指向帖子(Post)的Pointer原本展示为：

     {
     "__type": "Pointer",
     "className": "Post",
     "objectId": "51e3a359e4b015ead4d95ddc"
     }
     当一个查询使用include参数来包含进去来取代 Pointer 之后，可以看到 Pointer 被展开为：

     {
     "__type": "Object",
     "className": "Post",
     "objectId": "51e3a359e4b015ead4d95ddc",
     "createdAt": "2011-12-06T20:59:34.428Z",
     "updatedAt": "2011-12-06T20:59:34.428Z",
     "otherFields": "willAlsoBeIncluded"
     }
     您可以同样做多层的include, 这时要使用 "." 号. 如果您要include一条评论(Comment)对应的帖子(Post)的作者(author)： include的Key必须是Pointer类型

     rel.query({
     "table":"Comment",
     "order":"-createdAt",
     "limit":10,
     "include":"post.author"
     },function(err,data){
     //回调函数
     });
     */
    model.query = function (request, callback) {
        __Request("classes", request.table, request.objectId, 'GET', request, callback);
    }

    /**
     删除关联关系
     可以在一个对象中删除一个关系:

     rel.delete({
     "table":"GameScore",
     "objectId":"8106dc7c9e",
     "data":{"gamerel":{"__op":"RemoveRelation","objects":[{"__type":"Pointer","className":"Game","objectId":"ekZq111a"}]}}
     },function(err,data){
     //回调函数
     });
     */
    model.delete = function (request, callback) {
        __Request("classes", request.table, request.objectId, 'PUT', request.data, callback);
    }

    return model;
})();